<!doctype html>
<html lang='en'>

<head>
  <meta charset='utf-8'>
  <title>Vizality | Coming Soon</title>
  <meta name='description' content='A Discord app client modification, allowing for a truly customizable experience through the use of plugins, themes, and built-in settings.'>
  <meta name='theme-color' content='#267366'>
  <meta name='viewport' content='width=device-width, initial-scale=1'>

  <meta property='og:type' content='website'>
  <meta property='og:title' content='Vizality | Coming Soon'>
  <meta property='og:url' content='https://vizality.com'>
  <meta property='og:site_name' content='Vizality'>
  <meta property='og:description' content='A Discord app client modification, allowing for a truly customizable experience through the use of plugins, themes, and built-in settings.'>
  <meta property='og:image' content='https://vizality.com/assets/images/web.png'>
  <meta property='og:image:width' content='1200'>
  <meta property='og:image:height' content='630'>

  <meta property='twitter:card' content='summary_large_image'>
  <meta property='twitter:site' content='@vizality'>
  <meta property='twitter:title' content='Vizality'>
  <meta property='twitter:description' content='A Discord app client modification, allowing for a truly customizable experience through the use of plugins, themes, and built-in settings.'>
  <meta property='twitter:image:src' content='https://vizality.com/assets/images/web.png'>
  <meta property='twitter:image:width' content='1200'>
  <meta property='twitter:image:height' content='630'>

  <link rel="icon" href="favicon.ico">
  <link rel="apple-touch-icon" href="icon.png">

  <link href="https://fonts.googleapis.com/css?family=Roboto:500,900&display=swap" rel="stylesheet">
  <link id="stylesheet" type="text/css" href="assets/css/main.css" rel="stylesheet" />

  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-27328005-4"></script>
  <script>
    window.dataLayer = window.dataLayer || [];

    function gtag() {
      dataLayer.push(arguments);
    }
    gtag('js', new Date());

    gtag('config', 'UA-27328005-4');
  </script>
  <script>
    /**
 * Class to interact with Vizality through Discord's RPC WebSocket server.
 * @link https://gist.github.com/Bowser65/5756e490860aa122f5ad13f5cf19fd7d
 * @author Bowser65, modified by AAGaming00 and dperolio
 * @licence MIT
 */
class VizalityRPC {
    get ws () {
      return this._ws;
    }
  
    set ws (ws) {
      // Prevents multiple alive WebSockets
      if (this._ws) {
        this._ws.close();
      }
      this._ws = ws;
    }
  
    /**
     * Checks if there is an available Powercord-decorated RPC server.
     * @returns {Promise<boolean>}
     */
    async isRPCAvailable () {
      if (this.ws) {
        return true;
      }
  
      try {
        await this._connect();
        return true;
      } catch (ignored) {
        return false;
      }
    }
  
    /**
     * Opens Powercord's store page for a given product.
     * @param type {String} Type of product.
     * @param id {String} Plugin ID.
     * @returns {Promise<object>}
     */
    installProduct (type, id) {
      if (![ 'plugin', 'theme' ].includes(type)) {
        throw new Error('Invalid product type');
      }
      return this.sendRaw('VIZALITY_OPEN_STORE', {
        type,
        id
      });
    }
  
    /**
     * Open settings for a given product.
     * @param type {String} Type of product.
     * @param id {String} Plugin ID.
     * @returns {Promise<object>}
     */
    openProductSettings (type, id) {
      if (![ 'plugin', 'theme' ].includes(type)) {
        throw new Error('Invalid product type');
      }
      return this.sendRaw('VIZALITY_OPEN_SETTINGS', {
        type,
        id
      });
    }
  
    /**
     * Sends a message to Discord's RPC server
     * @param event {String} Name of the event
     * @param args {object} Data to send
     * @returns {Promise<object>}
     */
    sendRaw (event, args) {
      return new Promise(async (resolve, reject) => {
        if (!this.ws) {
          try {
            await this._connect();
          } catch (e) {
            reject(e);
            return;
          }
        }
  
        const nonce = this._v4();
        this._callbacks[nonce] = resolve;
        this.ws.send(JSON.stringify({
          cmd: event,
          args,
          nonce
        }));
      });
    }
  
    /**
     * Connects to Discord's RPC WebSocket
     * @returns {Promise<WebSocket>}
     * @private
     */
    _connect (portInc = 0) {
      const port = VizalityRPC.RPC_STARTING_PORT + portInc;
      this._log('Attempting to connect on port', port);
      return new Promise(async (resolve, reject) => {
        this._callbacks = {};
        this._ready = false;
        try {
          // DISCOVERY
          const res = await fetch(`http://127.0.0.1:${port}/`);
          if (res.status === 404) {
            const data = await res.json();
            if (data.code === 0) {
              this._log('Discovered Discord RPC on port', port);
            } else {
              // noinspection ExceptionCaughtLocallyJS
              throw new Error('Discovery failed');
            }
          } else {
            // noinspection ExceptionCaughtLocallyJS
            throw new Error('Discovery failed');
          }
  
          // CONNECTING
          this.ws = new WebSocket(`ws://127.0.0.1:${port}/?v=${VizalityRPC.RPC_VERSION}&client_id=vizality`);
          this.ws.addEventListener('message', msg => {
            const data = JSON.parse(msg.data);
            if (!this._ready && data.cmd === 'DISPATCH' && data.evt === 'READY') {
              this._log('Connection successful');
              this._ready = true;
              this.sendRaw('IS_VIZALITY')
              .then(() => {
              resolve()
              this._log('Found Vizality RPC')
              })
              .catch(() => {
                if (portInc++ === VizalityRPC.RPC_PORT_RANGE) {
                    reject(new Error('No available RPC'));
                    return
                  }
                  setTimeout(() => {
                    this._connect(portInc).then(resolve).catch(reject);              
                  }, 100);
                  this.ws.close()
              })
            } else if (this._ready) {
              const callback = this._callbacks[data.nonce];
              if (callback) {
                return callback(data.data);
              }
            }
          });
          this.ws.addEventListener('close', (e) => {
            this._log('Connection closed.', e.code, e.reason || 'Unknown', e.wasClean);
            Object.values(this._callbacks).forEach(cb => cb());
            this.ws = null;
          });
        } catch (e) {
          this._log('Connection failed.');
          console.log(portInc)
          if (portInc++ === VizalityRPC.RPC_PORT_RANGE) {
            reject(new Error('No available RPC'));
            return
          }
          setTimeout(() => {
            this._connect(portInc).then(resolve).catch(reject);              
          }, 100);
        }
      });
    }
  
    /**
     * Genrates a random UUID v4
     * @returns {string} Generated UUID
     * @private
     */
    _v4 () {
      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
        const r = Math.random() * 16 | 0;
        const v = c === 'x' ? r : ((r & 0x3) | 0x8);
        return v.toString(16);
      });
    }
  
    _log (...args) {
      console.log('%c[VizalityRPC]', 'color: #7C41FF', ...args);
    }
  }
  
  VizalityRPC.RPC_STARTING_PORT = 6463;
  VizalityRPC.RPC_PORT_RANGE = 10;
  VizalityRPC.RPC_VERSION = 1;
  const rpc = new VizalityRPC()
  rpc._connect()
  </script>
</head>

<body>
  <div class="container">
    <h1 class="vizality-coming-soon">
      <div class="vizality-logo-img-container">
        <img class="vizality-logo-img" src="./assets/images/vz-logo.png" />
        <div class="coming-soon-txt-container">
          <span class="coming-txt">Coming</span>
          <span class="soon-txt">Soon</span>
        </div>
      </div>
    </h1>
  </div>
  <canvas id="canvas"></canvas>
  <script>
    var Canvas = document.getElementById('canvas');
    var ctx = Canvas.getContext('2d');

    var resize = function () {
      Canvas.width = Canvas.clientWidth;
      Canvas.height = Canvas.clientHeight;
    };
    window.addEventListener('resize', resize);
    resize();

    var elements = [];
    var presets = {};

    presets.o = function (x, y, s, dx, dy) {
      return {
        x: x,
        y: y,
        r: 12 * s,
        w: 5 * s,
        dx: dx,
        dy: dy,
        draw: function (ctx, t) {
          this.x += this.dx;
          this.y += this.dy;

          ctx.beginPath();
          ctx.arc(this.x + +Math.sin((50 + x + (t / 10)) / 100) * 3, this.y + +Math.sin((45 + x + (t / 10)) / 100) *
            4, this.r, 0, 2 * Math.PI, false);
          ctx.lineWidth = this.w;
          ctx.strokeStyle = '#202125';
          ctx.stroke();
        }
      }
    };

    presets.x = function (x, y, s, dx, dy, dr, r) {
      r = r || 0;
      return {
        x: x,
        y: y,
        s: 20 * s,
        w: 5 * s,
        r: r,
        dx: dx,
        dy: dy,
        dr: dr,
        draw: function (ctx, t) {
          this.x += this.dx;
          this.y += this.dy;
          this.r += this.dr;

          var _this = this;
          var line = function (x, y, tx, ty, c, o) {
            o = o || 0;
            ctx.beginPath();
            ctx.moveTo(-o + ((_this.s / 2) * x), o + ((_this.s / 2) * y));
            ctx.lineTo(-o + ((_this.s / 2) * tx), o + ((_this.s / 2) * ty));
            ctx.lineWidth = _this.w;
            ctx.strokeStyle = c;
            ctx.stroke();
          };

          ctx.save();

          ctx.translate(this.x + Math.sin((x + (t / 10)) / 100) * 5, this.y + Math.sin((10 + x + (t / 10)) / 100) *
            2);
          ctx.rotate(this.r * Math.PI / 180);

          line(-1, -1, 1, 1, '#202125');
          line(1, -1, -1, 1, '#202125');

          ctx.restore();
        }
      }
    };

    for (var x = 0; x < Canvas.width; x++) {
      for (var y = 0; y < Canvas.height; y++) {
        if (Math.round(Math.random() * 8000) == 1) {
          var s = ((Math.random() * 5) + 1) / 10;
          if (Math.round(Math.random()) == 1)
            elements.push(presets.o(x, y, s, 0, 0));
          else
            elements.push(presets.x(x, y, s, 0, 0, ((Math.random() * 3) - 1) / 10, (Math.random() * 360)));
        }
      }
    }

    setInterval(function () {
      ctx.clearRect(0, 0, Canvas.width, Canvas.height);

      var time = new Date().getTime();
      for (var e in elements)
        elements[e].draw(ctx, time);
    }, 10);
  </script>
</body>

</html>